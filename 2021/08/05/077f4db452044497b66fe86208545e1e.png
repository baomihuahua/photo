local function json2true(str,from,to) return true, from+3 end local function json2false(str,from,to) return false, from+4 end local function json2null(str, from, to) return nil, from+3 end local function json2nan(str, from, to) return nul, from+2 end local numberchars = {['-'] = true,['+'] = true,['.'] = true,['0'] = true,['1'] = true,['2'] = true,['3'] = true,['4'] = true,['5'] = true,['6'] = true,['7'] = true,['8'] = true,['9'] = true} local function json2number(str,from,to) local i = from+1 while(i<=to) do local char = string.sub(str, i, i) if not numberchars[char] then break end i = i + 1 end local num = tonumber(string.sub(str, from, i-1)) if not num then error(_format('json格式错误，不正确的数字, 错误位置:{from}', from)) end return num, i-1 end local function json2string(str,from,to) local ignor = false for i = from+1, to do local char = string.sub(str, i, i) if not ignor then if char == '\"' then return string.sub(str, from+1, i-1), i elseif char == '\\' then ignor = true end else ignor = false end end error(_format('json格式错误，字符串没有找到结尾, 错误位置:{from}', from)) end local function json2array(str,from,to)    local result = {}    from = from or 1    local pos = from+1    local to = to or string.len(str)    while(pos<=to) do        local char = string.sub(str, pos, pos)        if char == '\"' then            result[#result+1], pos = json2string(str,pos,to)        elseif char == '[' then            result[#result+1], pos = json2array(str,pos,to)        elseif char == '{' then            result[#result+1], pos = json2table(str,pos,to)        elseif char == ']' then            return result, pos        elseif (char=='f' or char=='F') then            result[#result+1], pos = json2false(str,pos,to)        elseif (char=='t' or char=='T') then            result[#result+1], pos = json2true(str,pos,to)        elseif (char=='n') then            result[#result+1], pos = json2null(str,pos,to)        elseif (char=='N') then            result[#result+1], pos = json2nan(str,pos,to)        elseif numberchars[char] then            result[#result+1], pos = json2number(str,pos,to)        end        pos = pos + 1    end    error(_format('json格式错误，表没有找到结尾, 错误位置:{from}', from)) end function _G.json2table(str,from,to)    local result = {}    from = from or 1    local pos = from+1    local to = to or string.len(str)    local key    while(pos<=to) do        local char = string.sub(str, pos, pos)        if char == '\"' then            if not key then                key, pos = json2string(str,pos,to)            else                result[key], pos = json2string(str,pos,to)                key = nil            end        elseif char == '[' then            if not key then                key, pos = json2array(str,pos,to)            else                result[key], pos = json2array(str,pos,to)                key = nil            end        elseif char == '{' then            if not key then                key, pos = json2table(str,pos,to)            else                result[key], pos = json2table(str,pos,to)                key = nil            end        elseif char == '}' then            return result, pos        elseif (char=='f' or char=='F') then            result[key], pos = json2false(str,pos,to)            key = nil        elseif (char=='t' or char=='T') then            result[key], pos = json2true(str,pos,to)            key = nil        elseif (char=='n') then            result[key], pos = json2null(str,pos,to)            key = nil        elseif (char=='N') then            result[key], pos = json2nan(str,pos,to)            key = nil        elseif numberchars[char] then            if not key then                key, pos = json2number(str,pos,to)            else                result[key], pos = json2number(str,pos,to)                key = nil            end        end        pos = pos + 1    end    error(_format('格式错误，表没有找到结尾, 错误位置:{from}', from)) end local jsonfuncs={['\"']=json2string,['[']=json2array,['{']=json2table,['f']=json2false,['F']=json2false,['t']=json2true,['T']=json2true} function json2lua(str) if str==nil then gg.alert('错误json') else local char = string.sub(str, 1, 1) local func=jsonfuncs[char] if func then return func(str, 1, string.len(str)) end if numberchars[char] then return json2number(str, 1, string.len(str)) end end end

function md5(code) local code = tostring(code) local HexTable = {"0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"} local A = 0x67452301 local B = 0xefcdab89 local C = 0x98badcfe local D = 0x10325476 local S11 = 7 local S12 = 12 local S13 = 17 local S14 = 22 local S21 = 5 local S22 = 9 local S23 = 14 local S24 = 20 local S31 = 4 local S32 = 11 local S33 = 16 local S34 = 23 local S41 = 6 local S42 = 10 local S43 = 15 local S44 = 21 local function F(x,y,z) return (x & y) | ((~x) & z) end local function G(x,y,z) return (x & z) | (y & (~z)) end local function H(x,y,z) return x ~ y ~ z end local function I(x,y,z) return y ~ (x | (~z)) end local function FF(a,b,c,d,x,s,ac) a = a + F(b,c,d) + x + ac a = (((a & 0xffffffff) << s) | ((a & 0xffffffff) >> 32 - s)) + b return a & 0xffffffff end local function GG(a,b,c,d,x,s,ac) a = a + G(b,c,d) + x + ac a = (((a & 0xffffffff) << s) | ((a & 0xffffffff) >> 32 - s)) + b return a & 0xffffffff end local function HH(a,b,c,d,x,s,ac) a = a + H(b,c,d) + x + ac a = (((a & 0xffffffff) << s) | ((a & 0xffffffff) >> 32 - s)) + b return a & 0xffffffff end local function II(a,b,c,d,x,s,ac) a = a + I(b,c,d) + x + ac a = (((a & 0xffffffff) << s) | ((a & 0xffffffff) >> 32 - s)) + b return a & 0xffffffff end local function MD5StringFill(s) local len = s:len() local mod512 = len * 8 % 512 local fillSize = (448 - mod512) // 8 if mod512 > 448 then fillSize = (960 - mod512) // 8 end local rTab = {} local byteIndex = 1 for i = 1,len do local index = (i - 1) // 4 + 1 rTab[index] = rTab[index] or 0 rTab[index] = rTab[index] | (s:byte(i) << (byteIndex - 1) * 8) byteIndex = byteIndex + 1 if byteIndex == 5 then byteIndex = 1 end end local b0x80 = false local tLen = #rTab if byteIndex ~= 1 then rTab[tLen] = rTab[tLen] | 0x80 << (byteIndex - 1) * 8 b0x80 = true end for i = 1,fillSize // 4 do if not b0x80 and i == 1 then rTab[tLen + i] = 0x80 else rTab[tLen + i] = 0x0 end end local bitLen = math.floor(len * 8) tLen = #rTab rTab[tLen + 1] = bitLen & 0xffffffff rTab[tLen + 2] = bitLen >> 32 return rTab end function getmd5(s) local fillTab = MD5StringFill(s) local result = {A,B,C,D} for i = 1,#fillTab // 16 do local a = result[1] local b = result[2] local c = result[3] local d = result[4] local offset = (i - 1) * 16 + 1 a = FF(a, b, c, d, fillTab[offset + 0], S11, 0xd76aa478) d = FF(d, a, b, c, fillTab[offset + 1], S12, 0xe8c7b756) c = FF(c, d, a, b, fillTab[offset + 2], S13, 0x242070db) b = FF(b, c, d, a, fillTab[offset + 3], S14, 0xc1bdceee) a = FF(a, b, c, d, fillTab[offset + 4], S11, 0xf57c0faf) d = FF(d, a, b, c, fillTab[offset + 5], S12, 0x4787c62a) c = FF(c, d, a, b, fillTab[offset + 6], S13, 0xa8304613) b = FF(b, c, d, a, fillTab[offset + 7], S14, 0xfd469501) a = FF(a, b, c, d, fillTab[offset + 8], S11, 0x698098d8) d = FF(d, a, b, c, fillTab[offset + 9], S12, 0x8b44f7af) c = FF(c, d, a, b, fillTab[offset + 10], S13, 0xffff5bb1) b = FF(b, c, d, a, fillTab[offset + 11], S14, 0x895cd7be) a = FF(a, b, c, d, fillTab[offset + 12], S11, 0x6b901122) d = FF(d, a, b, c, fillTab[offset + 13], S12, 0xfd987193) c = FF(c, d, a, b, fillTab[offset + 14], S13, 0xa679438e) b = FF(b, c, d, a, fillTab[offset + 15], S14, 0x49b40821) a = GG(a, b, c, d, fillTab[offset + 1], S21, 0xf61e2562) d = GG(d, a, b, c, fillTab[offset + 6], S22, 0xc040b340) c = GG(c, d, a, b, fillTab[offset + 11], S23, 0x265e5a51) b = GG(b, c, d, a, fillTab[offset + 0], S24, 0xe9b6c7aa) a = GG(a, b, c, d, fillTab[offset + 5], S21, 0xd62f105d) d = GG(d, a, b, c, fillTab[offset + 10], S22, 0x2441453) c = GG(c, d, a, b, fillTab[offset + 15], S23, 0xd8a1e681) b = GG(b, c, d, a, fillTab[offset + 4], S24, 0xe7d3fbc8) a = GG(a, b, c, d, fillTab[offset + 9], S21, 0x21e1cde6) d = GG(d, a, b, c, fillTab[offset + 14], S22, 0xc33707d6) c = GG(c, d, a, b, fillTab[offset + 3], S23, 0xf4d50d87) b = GG(b, c, d, a, fillTab[offset + 8], S24, 0x455a14ed) a = GG(a, b, c, d, fillTab[offset + 13], S21, 0xa9e3e905) d = GG(d, a, b, c, fillTab[offset + 2], S22, 0xfcefa3f8) c = GG(c, d, a, b, fillTab[offset + 7], S23, 0x676f02d9) b = GG(b, c, d, a, fillTab[offset + 12], S24, 0x8d2a4c8a) a = HH(a, b, c, d, fillTab[offset + 5], S31, 0xfffa3942) d = HH(d, a, b, c, fillTab[offset + 8], S32, 0x8771f681) c = HH(c, d, a, b, fillTab[offset + 11], S33, 0x6d9d6122) b = HH(b, c, d, a, fillTab[offset + 14], S34, 0xfde5380c) a = HH(a, b, c, d, fillTab[offset + 1], S31, 0xa4beea44) d = HH(d, a, b, c, fillTab[offset + 4], S32, 0x4bdecfa9) c = HH(c, d, a, b, fillTab[offset + 7], S33, 0xf6bb4b60) b = HH(b, c, d, a, fillTab[offset + 10], S34, 0xbebfbc70) a = HH(a, b, c, d, fillTab[offset + 13], S31, 0x289b7ec6) d = HH(d, a, b, c, fillTab[offset + 0], S32, 0xeaa127fa) c = HH(c, d, a, b, fillTab[offset + 3], S33, 0xd4ef3085) b = HH(b, c, d, a, fillTab[offset + 6], S34, 0x4881d05) a = HH(a, b, c, d, fillTab[offset + 9], S31, 0xd9d4d039) d = HH(d, a, b, c, fillTab[offset + 12], S32, 0xe6db99e5) c = HH(c, d, a, b, fillTab[offset + 15], S33, 0x1fa27cf8) b = HH(b, c, d, a, fillTab[offset + 2], S34, 0xc4ac5665) a = II(a, b, c, d, fillTab[offset + 0], S41, 0xf4292244) d = II(d, a, b, c, fillTab[offset + 7], S42, 0x432aff97) c = II(c, d, a, b, fillTab[offset + 14], S43, 0xab9423a7) b = II(b, c, d, a, fillTab[offset + 5], S44, 0xfc93a039) a = II(a, b, c, d, fillTab[offset + 12], S41, 0x655b59c3) d = II(d, a, b, c, fillTab[offset + 3], S42, 0x8f0ccc92) c = II(c, d, a, b, fillTab[offset + 10], S43, 0xffeff47d) b = II(b, c, d, a, fillTab[offset + 1], S44, 0x85845dd1) a = II(a, b, c, d, fillTab[offset + 8], S41, 0x6fa87e4f) d = II(d, a, b, c, fillTab[offset + 15], S42, 0xfe2ce6e0) c = II(c, d, a, b, fillTab[offset + 6], S43, 0xa3014314) b = II(b, c, d, a, fillTab[offset + 13], S44, 0x4e0811a1) a = II(a, b, c, d, fillTab[offset + 4], S41, 0xf7537e82) d = II(d, a, b, c, fillTab[offset + 11], S42, 0xbd3af235) c = II(c, d, a, b, fillTab[offset + 2], S43, 0x2ad7d2bb) b = II(b, c, d, a, fillTab[offset + 9], S44, 0xeb86d391) result[1] = result[1] + a result[2] = result[2] + b result[3] = result[3] + c result[4] = result[4] + d result[1] = result[1] & 0xffffffff result[2] = result[2] & 0xffffffff result[3] = result[3] & 0xffffffff result[4] = result[4] & 0xffffffff end local retStr = '' for i = 1,4 do for _ = 1,4 do local temp = result[i] & 0x0F local str = HexTable[temp + 1] result[i] = result[i] >> 4 temp = result[i] & 0x0F retStr = retStr .. HexTable[temp + 1] .. str result[i] = result[i] >> 4 end end return string.lower(retStr) end return getmd5(code) end
--md5加密 md5("加密内容")

ZZRc4 = {}
ZZMathBit = {}
function ZZMathBit.__xorBit(left, right) return (left + right) == 1 and 1 or 0 end function ZZMathBit.__base(left, right, op) if left < right then left, right = right, left end local res = 0 local shift = 1 while left ~= 0 do local ra = left % 2 local rb = right % 2 res = shift * op(ra,rb) + res shift = shift * 2 left = math.modf( left / 2) right = math.modf( right / 2) end return res end function ZZMathBit.xorOp(left, right) return ZZMathBit.__base(left, right, ZZMathBit.__xorBit) end function RC4(text,key,kasi)
  if kasi==false then str = text str=str:gsub("[%s%p]",""):upper() local index=1 local ret="" for index=1,str:len(),2 do ret=ret..string.char(tonumber(str:sub(index,index+1),16)) end text=ret end local function KSA(key) local keyLen = string.len(key) local schedule = {} local keyByte = {} for i = 0, 255 do schedule[i] = i end for i = 1, keyLen do keyByte[i - 1] = string.byte(key, i, i) end local j = 0 for i = 0, 255 do j = (j + schedule[i] + keyByte[ i % keyLen]) % 256 schedule[i], schedule[j] = schedule[j], schedule[i] end return schedule end local function PRGA(schedule, textLen) local i = 0 local j = 0 local k = {} for n = 1, textLen do i = (i + 1) % 256 j = (j + schedule[i]) % 256 schedule[i], schedule[j] = schedule[j], schedule[i] k[n] = schedule[(schedule[i] + schedule[j]) % 256] end return k end local function output(schedule, text) local len = string.len(text) local c = nil local res = {} for i = 1, len do c = string.byte(text, i,i) res[i] = string.char(ZZMathBit.xorOp(schedule[i], c)) end return table.concat(res) end local textLen = string.len(text) local schedule = KSA(key) local k = PRGA(schedule, textLen) str=output(k, text) if kasi==true then str = tostring(str) local index=1 local ret="" for index=1,str:len() do ret=ret..string.format("%02X",str:sub(index):byte()) end return string.lower(ret) else return str end end
--极简云RC42加密和解密配置     RC4("加密内容","密码",false=解密_true=加密)

function ultra(get,post) local c=gg.makeRequest(get,nil,post).content  if c==nil then gg.alert("网络错误了，请检查你的网络") os.exit() end return c  end
--请求
function download(get,address) local c=gg.makeRequest(get,nil,nil).content  if c==nil then gg.alert("网络错误了，请检查你的网络") os.exit() end io.open(address,"w+"):write(c) gg.toast("下载成功") end
--下载文件


---[=[上面不要乱动]=]-------------------------------------------------------------------------------------------------------------------

local xxxxxxx="http://simpleauth.cn"
--官网

local xxxxxxx_Kami=xxxxxxx.."/api.php?api=kmlogon"
--接口名称[卡密登录]

local xxxxxxx_jieba=xxxxxxx.."/api.php?api=kmunmachine"
--接口名称[卡密解绑]

local xxxxxxx_to_configure=xxxxxxx.."/api.php?api=ini"
--接口名称[应用配置]

local xxxxxxx_Notice=xxxxxxx.."/api.php?api=notice"
--接口名称[应用公告]

---[=[  上面是对接  ]=]-------------------------------------------------------------------------------------------------------------------

local xxxxxxx_APPID='14127'
--APPID

local xxxxxxx_APPKEY='Fqsz4wJJCCJ8zsN8'
--APPKEY

local xxxxxxx_RC4_key='EFqAGAQOJqQBARqf'
--是否 RC4 加密[key 密钥]


local xxxbanb='1.0'
--1.0


local xxxxxxx_RC4=true
--是否 RC4 加密[false=关 true=开]
--选择 RC4加密-2 否则会乱码
--打开 签名放DATA里:打开


AMI_YDO="/sdcard/Android/"
--卡密 设备码 路径

----------------------------------------------------------------------------------------------------------------------

if xxxxxxx_APPID=="" or xxxxxxx_APPKEY=="" then
  gg.alert("对接数据,空...")--对话框
  os.exit()
end

----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------


file=ultra(xxxxxxx_to_configure.."&app="..xxxxxxx_APPID,"")
if xxxxxxx_RC4 == true then
  file=RC4(file,xxxxxxx_RC4_key,false)
  gg.setVisible(false)
end
if json2lua(file).code ~= 200 then
gg.alert("应用配置接口："..json2lua(file).msg)--错误提示
os.exit()
else

api_total=json2lua(file).msg.api_total
--调用几次接口[ 判断使用人数 ]

app_update_must=json2lua(file).msg.app_update_must
--是否强行更新 y是 n否

app_update_show=json2lua(file).msg.app_update_show
--更新内容

app_update_url=json2lua(file).msg.app_update_url
--更新地址

version=json2lua(file).msg.version
--版本号

version_info=json2lua(file).msg.version_info
--应用版本信息


if version == xxxbanb then
gg.setVisible(false)
gg.toast("最新版")--提示
else

if app_update_must=="y" then
gg.setVisible(false)
gg.alert("强制更新："..app_update_show,"下载")--对话框
if app_update_url ~=""  then
download(app_update_url,"/sdcard/新版本.lua")
os.exit()
else
gg.alert("没有找到更新下载链接!，请联系客服")--对话框
os.exit()
end

else
gg.setVisible(false)
gg.alert("更新内容："..app_update_show,"下载")--对话框
if app_update_url ~=""  then
download(app_update_url,"/sdcard/新版本.lua")
else
gg.alert("没有找到更新下载链接!，请联系客服")--对话框
os.exit()
end

end
end

end

----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------

Notice=ultra(xxxxxxx_Notice.."&app=".. xxxxxxx_APPID,"")
if xxxxxxx_RC4 == true then
  Notice=RC4(Notice,xxxxxxx_RC4_key,false)
  gg.setVisible(false)
end


if json2lua(Notice)['code'] == 200 then
if json2lua(Notice)['app_gg'] ~= nil then
gg.alert("公告："..json2lua(Notice).msg.app_gg)--对话框
end
else
gg.alert("公告接口："..json2lua(Notice).msg)--对话框
os.exit()
end

----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------



function MIAN()
miei=io.open(AMI_YDO..'/miei.log','r')
if miei==nil or miei:read("*a")== "" then 
miei=md5(os.time()*1000+611-99999)
io.open(AMI_YDO..'/miei.log','w+'):write(miei)--写
else
miei=io.open(AMI_YDO..'/miei.log','r'):read("*a")--读
end--设备码


function KM_G(km)---[=[ 卡密解绑 ]=]-------------------------------------------------------------------------------------------------------------------
key=md5("kami="..km.."&markcode="..miei.."&t="..os.time().."&".. xxxxxxx_APPKEY)
--签名
bops="kami="..km.."&markcode="..miei.."&t="..os.time().."&sign="..key
--合成发送数据
if  xxxxxxx_RC4 == true then
bops= "data="..RC4(bops,xxxxxxx_RC4_key,true) 
end

HUT=ultra(xxxxxxx_jieba.."&app=".. xxxxxxx_APPID,bops)

if  xxxxxxx_RC4 == true then
HUT=RC4(HUT,xxxxxxx_RC4_key,false) 
end-- xxxxxxx_Base64
return HUT
end


km=io.open(AMI_YDO..'/km.log','r') 
if km==nil  then else 
km=io.open(AMI_YDO..'/km.log','r'):read("*a")
end--卡密保存到本地


e=io.open(AMI_YDO..'/e.log','r')
if e==nil or e:read("*a")== "" then 
e="1"
io.open(AMI_YDO..'/e.log','w+'):write(e)--写
else
e=io.open(AMI_YDO..'/e.log','r'):read("*a")--读
end--储存自动登入
if e== "1" then e=false else  e=true 

end


Random=md5(os.time()*1000+611*os.time()-999999)..xxxxxxx_APPKEY..miei
--随机[用来计算是否相等]
function KM_L(km)---[=[ 卡密登入 ]=]-------------------------------------------------------------------------------------------------------------------
key=md5("kami="..km.."&markcode="..miei.."&t="..os.time().."&".. xxxxxxx_APPKEY)
--计算签名

bops="kami="..km.."&markcode="..miei.."&t="..os.time().."&sign="..key
--需要请求的数据

if  xxxxxxx_RC4 == true then
bops="data="..RC4(bops,xxxxxxx_RC4_key,true)
end-- 把请求数据用RC4加密

HUT=ultra(xxxxxxx_Kami.."&app=".. xxxxxxx_APPID,bops.."&value="..Random)
--请求数据

if  xxxxxxx_RC4 == true then
HUT=RC4(HUT,xxxxxxx_RC4_key,false) 
end-- 把返回的数据用RC4解密
KM_L=json2lua(HUT)

code=KM_L.code--判断整数 200是成功
msg=KM_L.msg--数据提示 也是错误提示
check=KM_L.check--验证数据
time=KM_L.time--返回时间

if check~= md5(time..xxxxxxx_APPKEY..Random) then
gg.alert("脚本：检测到你有非法操作")--对话框
os.exit()
end

if time-os.time()>30 or time-os.time()<-30 then
gg.alert("脚本：数据过期")--对话框
os.exit()
end

if code~= 200 then
io.open(AMI_YDO..'/e.log','w+'):write(1)--写
gg.alert(msg)--对话框
MIAN()
else

TT=gg.alert([[

到期时间: ]]..os.date("%Y".."年".."%m".."月".."%d".."日  %H".."时".."%M".."分".."%S".."秒",msg.vip)..[[


使用卡密: ]]..msg.kami
,"确定","返回")--对话框
io.open(AMI_YDO..'/km.log','w+'):write(msg.kami)--写

if TT== 2 then
io.open(AMI_YDO..'/e.log','w+'):write("1")--写
MIAN()
else

---[=[   ]=]-------------------------------------------------------------------------------------------------------------------




function split(szFullString, szSeparator) local nFindStartIndex = 1 local nSplitIndex = 1 local nSplitArray = {} while true do local nFindLastIndex = string.find(szFullString, szSeparator, nFindStartIndex) if not nFindLastIndex then nSplitArray[nSplitIndex] = string.sub(szFullString, nFindStartIndex, string.len(szFullString)) break end nSplitArray[nSplitIndex] = string.sub(szFullString, nFindStartIndex, nFindLastIndex - 1) nFindStartIndex = nFindLastIndex + string.len(szSeparator) nSplitIndex = nSplitIndex + 1 end return nSplitArray end function xgxc(szpy, qmxg) for x = 1, #(qmxg) do xgpy = szpy + qmxg[x]["offset"] xglx = qmxg[x]["type"] xgsz = qmxg[x]["value"] xgdj = qmxg[x]["freeze"] if xgdj == nil or xgdj == "" then gg.setValues({[1] = {address = xgpy, flags = xglx, value = xgsz}}) else gg.addListItems({[1] = {address = xgpy, flags = xglx, freeze = xgdj, value = xgsz}}) end xgsl = xgsl + 1 xgjg = true end end function xqmnb(qmnb) gg.clearResults() gg.setRanges(qmnb[1]["memory"]) gg.searchNumber(qmnb[3]["value"], qmnb[3]["type"]) if gg.getResultCount() == 0 then gg.toast(qmnb[2]["name"] .. "开启失败") else gg.refineNumber(qmnb[3]["value"], qmnb[3]["type"]) gg.refineNumber(qmnb[3]["value"], qmnb[3]["type"]) gg.refineNumber(qmnb[3]["value"], qmnb[3]["type"]) if gg.getResultCount() == 0 then gg.toast(qmnb[2]["name"] .. "开启失败") else sl = gg.getResults(999999) sz = gg.getResultCount() xgsl = 0 if sz > 999999 then sz = 999999 end for i = 1, sz do pdsz = true for v = 4, #(qmnb) do if pdsz == true then pysz = {} pysz[1] = {} pysz[1].address = sl[i].address + qmnb[v]["offset"] pysz[1].flags = qmnb[v]["type"] szpy = gg.getValues(pysz) pdpd = qmnb[v]["lv"] .. ";" .. szpy[1].value szpd = split(pdpd, ";") tzszpd = szpd[1] pyszpd = szpd[2] if tzszpd == pyszpd then pdjg = true pdsz = true else pdjg = false pdsz = false end end end if pdjg == true then szpy = sl[i].address xgxc(szpy, qmxg) end end if xgjg == true then gg.toast(qmnb[2]["name"] .. "开启成功,共修改" .. xgsl .. "条数据") else gg.toast(qmnb[2]["name"] .. "开启失败") end end end end
function Main()
SN = gg.multiChoice({"大厅防10年","大厅防禁网","退出脚本",}, nil, "火力全开随便打QQ3062692349")
if SN == nil then else
if SN[1] == true then A1() end
if SN[2] == true then A2() end
if SN[3] == true then kk() end
end XGCK = -1 end
function A1()
gg.clearResults()
gg.setRanges(gg.REGION_C_ALLOC)
gg.searchNumber("134914;131330", gg.TYPE_DWORD)
gg.refineNumber("134914", gg.TYPE_DWORD)
gg.getResults(50500)
gg.editAll("67109633", gg.TYPE_DWORD)
gg.setRanges(gg.REGION_C_ALLOC)
gg.searchNumber("134658;135682", gg.TYPE_DWORD)
gg.getResults(50500)
gg.editAll("67109633", gg.TYPE_DWORD)
gg.setRanges(gg.REGION_C_ALLOC)
gg.searchNumber("131586;131842", gg.TYPE_DWORD)
gg.getResults(50500)
gg.editAll("67109633", gg.TYPE_DWORD)
gg.setRanges(gg.REGION_C_ALLOC)
gg.searchNumber("132098;133635", gg.TYPE_DWORD)
gg.getResults(50500)
gg.editAll("67109633", gg.TYPE_DWORD)
gg.setRanges(gg.REGION_C_ALLOC)
gg.searchNumber("12547;70658", gg.TYPE_DWORD)
gg.getResults(50500)
gg.editAll("67109633", gg.TYPE_DWORD)
gg.setRanges(gg.REGION_C_ALLOC)
gg.searchNumber("134,402;135,682", gg.TYPE_DWORD)
gg.getResults(50500)
gg.editAll("67109633", gg.TYPE_DWORD)
gg.setRanges(gg.REGION_C_ALLOC)
gg.searchNumber("133,634;4,194,304", gg.TYPE_DWORD)
gg.getResults(50500)
gg.editAll("67109633", gg.TYPE_DWORD)
gg.setRanges(gg.REGION_C_ALLOC)
gg.searchNumber("43,520;133,635", gg.TYPE_DWORD)
gg.getResults(50500)
gg.editAll("67109633", gg.TYPE_DWORD)
gg.clearResults()
gg.setRanges(gg.REGION_C_ALLOC)
gg.searchNumber('134,914;134,402',gg.TYPE_DWORD,false,gg.SIGN_EQUAL,0,-1)
gg.searchNumber('',gg.TYPE_DWORD,false,gg.SIGN_EQUAL,0,-1)
gg.getResults(5000)
gg.editAll('67109633',gg.TYPE_DWORD)
gg.toast('开启成功')
gg.clearResults()
gg.clearResults()
gg.setRanges(gg.REGION_C_ALLOC)
gg.searchNumber('66,048;65,537',gg.TYPE_DWORD,false,gg.SIGN_EQUAL,0,-1)
gg.searchNumber('',gg.TYPE_DWORD,false,gg.SIGN_EQUAL,0,-1)
gg.getResults(5000)
gg.editAll('67109633',gg.TYPE_DWORD)
gg.toast('开启成功')
gg.clearResults()
gg.clearResults()
gg.setRanges(gg.REGION_C_ALLOC)
gg.searchNumber('133,634;4,194,304',gg.TYPE_DWORD,false,gg.SIGN_EQUAL,0,-1)
gg.searchNumber('',gg.TYPE_DWORD,false,gg.SIGN_EQUAL,0,-1)
gg.getResults(5001)
gg.editAll('67109633',gg.TYPE_DWORD)
gg.toast('开启成功')
gg.clearResults()
gg.clearResults()
gg.setRanges(gg.REGION_C_ALLOC)
gg.searchNumber('43,520',gg.TYPE_DWORD,false,gg.SIGN_EQUAL,0,-1)
gg.searchNumber('43,520',gg.TYPE_DWORD,false,gg.SIGN_EQUAL,0,-1)
gg.getResults(5000)
gg.editAll('67109633',gg.TYPE_DWORD)
gg.toast('开启成功')
gg.clearResults()
end
function A2()
gg.clearResults()
gg.setRanges(4)
gg.searchNumber("196864;16842753", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1)
gg.refineNumber("10240", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1)
revert = gg.getResults(10000, nil, nil, nil, nil, nil, nil, nil, nil)
local t = gg.getResults(10000, nil, nil, nil, nil, nil, nil, nil, nil)
for i, v in ipairs(t) do
	if v.flags == gg.TYPE_DWORD then
		v.value = "0"
		v.freeze = true
	end
end
gg.addListItems(t)
t = nil
gg.clearResults()
gg.setRanges(4)
gg.searchNumber("10240;6582895", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1)
gg.refineNumber("10240", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1)
revert = gg.getResults(10000, nil, nil, nil, nil, nil, nil, nil, nil)
local t = gg.getResults(10000, nil, nil, nil, nil, nil, nil, nil, nil)
for i, v in ipairs(t) do
	if v.flags == gg.TYPE_DWORD then
		v.value = "0"
		v.freeze = true
	end
end
gg.addListItems(t)
t = nil
gg.clearResults()
gg.setRanges(4)
gg.searchNumber("10240;10241", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1)
gg.refineNumber("10240", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1)
revert = gg.getResults(10000, nil, nil, nil, nil, nil, nil, nil, nil)
local t = gg.getResults(10000, nil, nil, nil, nil, nil, nil, nil, nil)
for i, v in ipairs(t) do
	if v.flags == gg.TYPE_DWORD then
		v.value = "0"
		v.freeze = true
	end
end
gg.addListItems(t)
t = nil
gg.clearResults()
gg.setRanges(4)
gg.searchNumber("16777730", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1)
revert = gg.getResults(10000, nil, nil, nil, nil, nil, nil, nil, nil)
local t = gg.getResults(10000, nil, nil, nil, nil, nil, nil, nil, nil)
for i, v in ipairs(t) do
if v.flags == gg.TYPE_DWORD then
v.value = "0"
v.freeze = true
end
end
gg.addListItems(t)
t = nil
gg.clearResults()
gg.setRanges(4)
gg.searchNumber("33619970", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1)
gg.refineNumber("33619970", gg.TYPE_DWORD, false, gg.SIGN_EQUAL, 0, -1)
revert = gg.getResults(10000, nil, nil, nil, nil, nil, nil, nil, nil)
local t = gg.getResults(10000, nil, nil, nil, nil, nil, nil, nil, nil)
for i, v in ipairs(t) do
if v.flags == gg.TYPE_DWORD then
v.value = "0"
v.freeze = true
end
end
gg.addListItems(t)
t = nil
end
function kk() os.exit() end while true do if gg.isVisible(true) then XGCK = 1 gg.setVisible(false) end gg.clearResults() if XGCK == 1 then Main() end end







---[=[   ]=]-------------------------------------------------------------------------------------------------------------------
end

     end

end



if km == nil  then
else
if km ~=""  then
if e==true then
KM_L(km)
end 
end
end



hak=gg.prompt({
[[全网使用次数：]]..api_total..[[

输入 >1< 解绑卡密
在下方输入你的卡密]],
"是否自动登入",
},{
km,
e
},{
'text',--文字
'checkbox',--多选
})--文本功能


if hak==nil then
elseif hak[2]==true then
io.open(AMI_YDO..'/e.log','w+'):write("2")--写
elseif hak[2]==false then
io.open(AMI_YDO..'/e.log','w+'):write("1")--写
end


if hak==nil then gg.setVisible(false) 
elseif hak[1]== "1" then
G_B=gg.prompt({"输入要解绑的卡密"},{},{"text"})
if  G_B[1]== "" then
gg.alert("空，请填写卡密")--对话框
else
KM_G=json2lua(KM_G(G_B[1]))
if KM_G.code== 200 then
else
gg.alert(KM_G.msg)--对话框
end
end
elseif hak[1]== "2" then

elseif hak[1]== "" then
gg.alert("空，请填写卡密")--对话框
else
KM_L(hak[1])
end

end









while true do
  if gg.isVisible(true) then
  MIAN()
  end
end
